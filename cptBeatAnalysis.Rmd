---
title: "Cape Town Beat anlysis"
author: "Elias J. Willemse (elias.willemse@up.ac.za)"
date: "10/25/2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Background

This document shows how the Cape Town beat analysis data were generated, using the following sources:

* GPS records for the waste fleet in 2014, 
* collection beat shape files,
* location of landfills, transfer stations and vehicle depots, 
* synthetic population, generated by Prof. Johan W. Joubert (johan.joubert@up.ac.za),
* income classification and tax brackets obtained online, and
* costing model input data, obtained through the Coursera MOOC, _Waste management for developing countries_, presented by Earwag and EPFL (Switzerland).

The GPS and waste beat data is stored in `../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db`.

## Libraries and generic functions

### Libraries

The following librariers are required for the analys.

```{r libraries, echo=FALSE}
library(tidyverse)
library(lubridate)
library(DBI)
library(geosphere)
library(ggmap)
```

### Functions

The following functions are used throughout the analysis:

```{r functions, echo=FALSE}
# Used to create a map like picture, without borderlines, coordinates, or axis. 
# The x-y coordinates are scaled correctly. Just +blank_all at the end of a ggplot.
blank_all = theme(axis.line=element_blank(),
                  axis.text.x=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks=element_blank(),
                  axis.title.x=element_blank(),
                  axis.title.y=element_blank(),
                  legend.position="none",
                  panel.background=element_blank(),
                  panel.border=element_blank(),
                  panel.grid.major=element_blank(),
                  panel.grid.minor=element_blank(),
                  plot.background=element_blank()) 

returnServiceArea <- function(vehicle.frame, mapBuffer)
{
  # Find the area for the GPS records
  minX = min(vehicle.frame$long) 
  minY = min(vehicle.frame$lat) 
  maxX = max(vehicle.frame$long) 
  maxY = max(vehicle.frame$lat) 
  
  # The area is increased by a buffer to prevent objects from being placed too close to the map borders.
  jiggle_X = (maxX - minX)*mapBuffer
  jiggle_Y = (maxY - minY)*mapBuffer
  
  # Increase the GPS area
  minX = minX - jiggle_X
  minY = minY - jiggle_Y
  maxX = maxX + jiggle_X
  maxY = maxY + jiggle_Y
  
  center_x <- (minX + maxX)/2
  center_y <- (minY + maxY)/2
  
  serviceArea = c(minX, minY, maxX, maxY, center_x, center_y)
  return(serviceArea)
}

loadGoogleMap <- function(serviceCenter, mapColor = "bw", mapType = "terrain", zoom = 10, 
                          googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:off")
{
  center_x <- serviceCenter[1]
  center_y <- serviceCenter[2]
  baseMap <- get_googlemap(center = c(center_x, center_y), color = mapColor, maptype = mapType, zoom = zoom, style = googleStyle, urlonly = FALSE, archiving = TRUE)
  return(baseMap)
}

returnMap <- function(vehicle.frame, mapBuffer = 0.05, mapColor = "bw", mapType = "terrain", zoomStart = 20, 
                      googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:off", 
                      returnZoom = F)
{
  # Get a rectangular box covering all the GPS points plus a 
  serviceArea <- returnServiceArea(vehicle.frame, mapBuffer)
  
  # Decode service area
  minX <- serviceArea[1]
  minY <- serviceArea[2]
  maxX <- serviceArea[3]
  maxY <- serviceArea[4]
  
  # The center (x, y) of the area is used to retrieve the map
  serviceCenter <- c(serviceArea[5], serviceArea[6])
  
  # The zoom level is decreased until all the service area is contained in the google map tile or the zoom level is at a continental level.
  stop <- FALSE
  zoomTest <- zoomStart
  while(stop == FALSE)
  {
    cat(paste('Load google map at scale:', zoomTest, '\n'))
    # Retrieve the map from google
    baseMap <- loadGoogleMap(serviceCenter, mapColor = mapColor, mapType = mapType, zoom = zoomTest, 
                             googleStyle = googleStyle)
    
    # Get the coordinates of the google tile
    ggBaseMap <- ggmap(baseMap, extent = "device")
    map_info <- ggplot_build(ggBaseMap)
    xmin <- map_info$data[[3]]$xmin
    ymin <- map_info$data[[3]]$ymin
    xmax <- map_info$data[[3]]$xmax
    ymax <- map_info$data[[3]]$ymax
    
    # Check if the service area is covered
    captured <- (minX > xmin) & (minY > ymin) & (maxX < xmax) & (maxY < ymax)
    if(captured == TRUE)
    {
      stop = TRUE # stop and return the map
    }else{
      zoomTest <- zoomTest - 1 # decrease zoom level
    }
    
    # Stop if the zoom level is at a continent level
    if(zoomTest == 3){stop = TRUE}
  }
  
  # if required the best zoom level can be returned
  if (returnZoom == TRUE)
  {
    return(list(ggBaseMap = ggBaseMap, bestZoom = zoomTest))
  }else{
    return(ggBaseMap)
  }
}

shiftVectorForward <- function(shiftVector)
{
  # Shifts vector forward, so that point i-1 is relocated to point i.
  # First point repeats, and last point is not used.
  # Used to calculate distance, speed, time, etc. between consequtive points (between i-1 and i).
  nPoints <- length(shiftVector)
  newVector <- c(shiftVector[1], shiftVector[1:(nPoints - 1)])
  return(newVector)
}

calcDeltaD <- function(pos_x, pos_y)
{
  # Calculate the distance between points i - 1 and i, and allocated it to point i. 
  # Returns a vector of the distances.
  # pos_x and pos_y has to be longitude (pos_x) and latitude (pos_y) degrees 
  # and ordered according to time. Requires the geosphere package.
  nPoints = length(pos_x)
  pos_x_prev = shiftVectorForward(pos_x)
  pos_y_prev = shiftVectorForward(pos_y)
  matrixPointsPrev = matrix(c(pos_x_prev, pos_y_prev), nrow = nPoints, ncol = 2)
  matrixPointsCurrent = matrix(c(pos_x, pos_y), nrow = nPoints, ncol = 2)
  distanceDelta = distGeo(matrixPointsPrev, matrixPointsCurrent)[2:nPoints]
  return(distanceDelta)
}

calcDeltaD_ref <- function(pos_x, pos_y, ref_x, ref_y)
{
  # Calculate the distance between points i and a reference point k. 
  # Returns a vector of the distances.
  # pos_x and pos_y has to be longitude (pos_x) and latitude (pos_y) degrees 
  # Requires the geosphere package.
  nPoints = length(pos_x)
  matrixPointsPrev = matrix(c(rep(ref_x, nPoints), rep(ref_y, nPoints)), nrow = nPoints, ncol = 2)
  matrixPointsCurrent = matrix(c(pos_x, pos_y), nrow = nPoints, ncol = 2)
  distanceDelta = distGeo(matrixPointsPrev, matrixPointsCurrent)
  return(distanceDelta)
}

identifyOutliers <- function(deltaT)
{
  # Find and remove outliers using box-plot heuristic.
  # Anything above or below 1.5 IQR from 1st and 3rd quartile.
  b <- boxplot(deltaT)
  upperBound <- b$stats[[5]]
  outLiers <- which((deltaT > upperBound)  == TRUE)
  return(outLiers)
}

findIF <-  function(disposelSite, subdayGPS)
{
  # Find the landfill or intermediate facility that a vehicle was closest too, therefore assumed visited,
  # during its travels. Does not work if a vehicle visited more than one.
  minDistOpt <- 1000000
  minDistI <- 0
  distToVec <- c()
  for (i in 1:nrow(dispose))
  {
    distTo <- calcDeltaD_ref(pos_x = subdayGPS$long, pos_y = subdayGPS$lat, ref_x = disposelSite$long[i], ref_y = disposelSite$lat[i])
    if (min(distTo) < minDistOpt)
    {
      minDistI <- i
      minDistOpt <- min(distTo)
      distToVec <- distTo
    }
  }
  return(list(minDistI, distToVec))
}

beatCost <- function(vehicleRec, anDay, beatI, dispose, kostPerKm = 16.484, kostPerHour = 178.816) # costValues spreadsheet under data/costs
{
  # Calculate the beat cost, which depends on travel cost (per km) and time cost (rand per hour)
  # Should be updated with the MOOC costs. It also splits the cost between service (inside collection area) and deadheading (outside).
  subday <- subset(vehicleRec, date == anDay)
  
  if (nrow(subday) < 100){return(c())}
  
  subday$time_con <- strptime(subday$time, format = '%T')
  subday <- subday[order(subday$time_con),]
  
  time_con2 <- as.numeric(subday$time_con)
  d <- diff(time_con2)
  
  timeDelta_sec <- as.numeric(diff(subday$time_con), units = "secs")
  
  subday2 <- subday[c(TRUE, timeDelta_sec > 1),]
  timeDelta_sec <- as.numeric(diff(subday2$time_con), units = "secs")
  
  distDiff_m <- calcDeltaD(subday2$long, subday2$lat)
  speed_ms <- distDiff_m/timeDelta_sec
  
  total_distance <- sum(distDiff_m)/1000
  start_end_point <- subday2[c(1,nrow(subday2)), ]
  
  
  subday2$depot_distance_start <- calcDeltaD_ref(pos_x = subday2$long, pos_y = subday2$lat, ref_x = subday2$long[1], ref_y = subday2$lat[1])
  
  subday2$depot_distance_end <- calcDeltaD_ref(pos_x = subday2$long, pos_y = subday2$lat, ref_x = subday2$long[nrow(subday2)], ref_y = subday2$lat[nrow(subday2)])
  
  startIndex <- which(subday2$depot_distance_start > 150)[1]
  
  endIndices <- which(subday2$depot_distance_end[startIndex:nrow(subday2)] < 150)
  indexRange <- max(endIndices) - min(endIndices)
  
  if (indexRange > 100)
  {
    max_diff <- diff(endIndices)
    max_diff_index <- which(max_diff == max(max_diff))
    endIndex <- endIndices[max_diff_index + 1]
  }else{
    endIndex <- which(subday2$depot_distance_end[startIndex:nrow(subday2)] < 150)[1]
  }
  
  totalTime <- as.numeric(as.duration(subday2$time_con[endIndex] - subday2$time_con[startIndex])/3600)
  
  ifResults <- findIF(dispose, subday2)
  subday2$calcDeltaD_ref <- ifResults[[2]] 
  
  chainIndexed <- which(subday2$calcDeltaD_ref < 150)
  
  nBreaks <- length(chainIndexed)
  
  subday2_chain_time <- c()
  subday2_chain_dist <- c()
  
  if (nBreaks > 0)
  {
    subday2_chain <- subset(subday2[1:chainIndexed[1],], WasteServiceBeatGroup_idWasteServiceBeatGroup == beatI)
    if (nrow(subday2_chain) > 0)
    {
      subday2_chain_time <- c(subday2_chain_time, as.duration(max(subday2_chain$time_con) - min(subday2_chain$time_con)))
      subday2_chain_dist <- c(subday2_chain_dist, calcDeltaD(subday2_chain$long, subday2_chain$lat))
    }
    if (nBreaks > 1)
    {
      for (i in 2:nBreaks)
      {
        subday2_chain <- subset(subday2[(chainIndexed[i-1]):chainIndexed[i],], WasteServiceBeatGroup_idWasteServiceBeatGroup == beatI)
        if (nrow(subday2_chain) > 0)
        {
          subday2_chain_time <- c(subday2_chain_time, as.duration(max(subday2_chain$time_con) - min(subday2_chain$time_con)))
          subday2_chain_dist <- c(subday2_chain_dist, calcDeltaD(subday2_chain$long, subday2_chain$lat))
        }
      }
    }
    subday2_chain <- subset(subday2[(chainIndexed[nBreaks]):nrow(subday2),], WasteServiceBeatGroup_idWasteServiceBeatGroup == beatI)
    if (nrow(subday2_chain) > 0)
    {
      subday2_chain_time <- c(subday2_chain_time, as.duration(max(subday2_chain$time_con) - min(subday2_chain$time_con)))
      subday2_chain_dist <- c(subday2_chain_dist, calcDeltaD(subday2_chain$long, subday2_chain$lat))
    }
  }else{
    subday2_chain <- subset(subday2, WasteServiceBeatGroup_idWasteServiceBeatGroup == beatI) 
  }
  
  tTotal <- sum(subday2_chain_time)/60/60
  totalDeadTime <- totalTime - tTotal
  timeUtilisation <- tTotal/totalTime
  kmTotal <- sum(subday2_chain_dist)/1000
  total_dead <- total_distance - kmTotal
  distanceUtilisation <- kmTotal/total_distance
  
  kmCost <- total_distance*kostPerKm
  timeCost <- totalTime*kostPerHour
  totalCost <- kmCost + timeCost
  
  serviceKmCost <- kmTotal*kostPerKm
  serviceTimeCost <- tTotal*kostPerHour
  serviceTotal <- serviceKmCost + serviceTimeCost
  
  costFraction <- serviceTotal/totalCost
  
  output = list(serviceTime = tTotal,
                totalTime = totalTime,
                totalDeadTime = totalDeadTime,
                timeUtilisation = timeUtilisation,
                serviceKm = kmTotal,
                totalKm = total_distance,
                totalDeadKm = total_dead,
                distanceUtilisation = distanceUtilisation,
                travelCost = kmCost,
                timeCost = timeCost,
                totalCost = totalCost,
                serviceTravelCost = serviceKmCost,
                serviceTimeCost = serviceTimeCost,
                serviceTotalCost = serviceTotal,
                serviceCostFraction = costFraction)
  
  output2 = c(tTotal,
              totalTime,
              totalDeadTime,
              timeUtilisation,
              kmTotal,
              total_distance,
              total_dead,
              distanceUtilisation,
              kmCost,
              timeCost,
              totalCost,
              serviceKmCost,
              serviceTimeCost,
              serviceTotal,
              costFraction)
  
  return(output2)
}
```

## Beat display

All the waste collection beats are displayed, with the option to map a single day's worth of GPS
records over all the beats. 

### Input data

The single beat, service day, vehicle and day to analyse are:

```{r input, echo=TRUE}
beatID = 679
serviceDay = 2
vehicleID = 285
analysisDay = '2014-02-18'
dayID = 44
zoomArea1_xlim = c(18.395, 18.746598)
zoomArea1_ylim = c(-34.106939, -33.764530)
```

### Actonville and Watville example map

Retrieve map of Actonville and Watville for illustration purposes:
```{r mapActonvilleWatville, echo=FALSE}
mapColor = "bw"
mapType = "terrain"
zoomStart = 12
googleStyle = "feature:all|element:labels|visibility:on&style=feature:road.local|visibility:on"
area_center <- c(28.303414, -26.214881)
baseMap <- get_googlemap(center = area_center, color = mapColor, maptype = mapType, zoom = zoomStart, style = googleStyle, urlonly = FALSE, archiving = TRUE)
ggmap(baseMap)

dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteVehicles_idWasteVehicles = :a'
vehicleRecords <- dbGetQuery(conDB, q, params = list(a = vehicleID))
nrow(vehicleRecords)

dbDisconnect(conDB)
```

### All records for single day

Retrieve, draw and save all GPS records for `r analysisDay` and a zoomed in area:

```{r dayGPSrecordsDay, echo=FALSE}
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE ServiceDates_idServiceDates = :a'
dateGpsRecords <- dbGetQuery(conDB, q, params = list(a = dayID))

q <- 'SELECT * FROM WasteServiceBoundaryPoint'
boundaryRecords <- dbGetQuery(conDB, q)

q <- 'SELECT * FROM WasteServiceBeatGroup'
beatRecords <- dbGetQuery(conDB, q)

dbDisconnect(conDB)

beatRecordsBoundary <- right_join(beatRecords, boundaryRecords, by = c('idWasteServiceBeatGroup' = 'WasteServiceBeat_idWasteServiceBeatGroup'))

beatRecordsBoundary_single <- beatRecordsBoundary %>% filter(idWasteServiceBeatGroup == beatID)

gpsDayPlotBase <- ggplot(data = dateGpsRecords, aes(x = long, y = lat, group = WasteVehicles_idWasteVehicles))  + blank_all + coord_quickmap()
gpsDayPath <- gpsDayPlotBase + geom_path(col = 'darkred', alpha = 0.1, size = 0.15)  + geom_path(data = beatRecordsBoundary_single, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col='black') 
gpsDayPathZoom <- gpsDayPath + scale_x_continuous(limits = zoomArea1_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea1_ylim, expand = c(0, 0))
#+ coord_fixed(ylim = zoomArea1_ylim,  xlim = zoomArea1_xlim, ratio = 1.3) 
gpsDayPathZoom

ggsave(gpsDayPathZoom, filename = 'gpsDayPath.pdf', width = 15, height = 18.75, units = 'cm')

dateGpsRecords_sub <- dateGpsRecords %>% filter(lat > zoomArea1_ylim[1] & lat < zoomArea1_ylim[2] & long > zoomArea1_xlim[1] & long < zoomArea1_xlim[2])

serviceMap <- returnMap(dateGpsRecords_sub, zoomStart = 13)

gpsDayMap <- serviceMap + geom_path(data = dateGpsRecords, aes(x = long, y = lat, group = WasteVehicles_idWasteVehicles), col = 'darkred', alpha = 0.15, size = 0.2)
gpsDayMapZoom <- gpsDayMap + scale_x_continuous(limits = zoomArea1_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea1_ylim, expand = c(0, 0)) 
gpsDayMapZoom

ggsave(gpsDayMapZoom, filename = 'gpsDayMapPath.pdf', width = 15, height = 18.75, units = 'cm')

length(dateGpsRecords$WasteVehicles_idWasteVehicles)
length(unique(dateGpsRecords$WasteVehicles_idWasteVehicles))
length(unique(dateGpsRecords$WasteServiceBeatGroup_idWasteServiceBeatGroup))

distanceDelta_x = distGeo(p1 = c(zoomArea1_xlim[1], zoomArea1_ylim[1]), p2 = c(zoomArea1_xlim[2], zoomArea1_ylim[1]))
distanceDelta_x/1000

distanceDelta_y = distGeo(p1 = c(zoomArea1_xlim[1], zoomArea1_ylim[1]), p2 = c(zoomArea1_xlim[1], zoomArea1_ylim[2]))
distanceDelta_y/1000
```

### All beats

Retrieve, draw and save all service beats in a zoomed in area with beat `r beatID` highlighted:

```{r dayGPSrecordsBeat, echo=FALSE}
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM WasteServiceBoundaryPoint'
boundaryRecords <- dbGetQuery(conDB, q)

q <- 'SELECT * FROM WasteServiceBeatGroup'
beatRecords <- dbGetQuery(conDB, q)

dbDisconnect(conDB)

beatRecordsBoundary <- right_join(beatRecords, boundaryRecords, by = c('idWasteServiceBeatGroup' = 'WasteServiceBeat_idWasteServiceBeatGroup'))

beatRecordsBoundary_single <- beatRecordsBoundary %>% filter(idWasteServiceBeatGroup == beatID)

gpsBeatPlotBase <- ggplot(beatRecordsBoundary, aes(x = long, y = lat, group = idWasteServiceBeatGroup)) + blank_all + coord_quickmap()

gpsBeatPlot <- gpsBeatPlotBase + geom_polygon(col = 'white', fill= '#aeaeaeff') + geom_polygon(data = beatRecordsBoundary_single, fill = "black", col = "white")
gpsBeatPlotZoom <- gpsBeatPlot + scale_x_continuous(limits = zoomArea1_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea1_ylim, expand = c(0, 0)) 
gpsBeatPlotZoom

ggsave(gpsBeatPlotZoom, filename = 'gpsBeats.pdf', width = 15, height = 18.75, units = 'cm')
```

### Beats gps records

Retrieve, draw and save all gps records for beat `r beatID`:

```{r dayGPSrecordsAll, echo=FALSE}
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteServiceBeatGroup_idWasteServiceBeatGroup = :a'
beatGpsRecords <- dbGetQuery(conDB, q, params = list(a = beatID))

dbDisconnect(conDB)

dateData <- read.csv('dateDatasetTraining.csv')
days = c(2)
beatGpsRecordsFilter <- beatGpsRecords %>% inner_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) 

beatMap <- returnMap(beatGpsRecordsFilter, zoomStart = 14, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")

beatRecords <- filter(beatRecordsBoundary, idWasteServiceBeatGroup == beatID)

x_buf = 0.004
y_buf = 0.004
zoomArea2_xlim <- c(beatRecords$boundBox_minLong[1] - x_buf, beatRecords$boundBox_maxLong[1] + x_buf)
zoomArea2_ylim <- c(beatRecords$boundBox_minLat[1] - y_buf, beatRecords$boundBox_maxLat[1] + y_buf)

beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkred', size = 1) + geom_point(data = beatGpsRecordsFilter, aes(x = long, y = lat), alpha = 0.25, size = 0.5, col = "black")  + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
beatPointMap

ggsave(beatPointMap, filename = 'gpsBeatAlonGPS.pdf', width = 15, height = 23.5, units = 'cm')
```

### Beat service vehicle records

Retrieve, draw and save all gps records for vehilce `r vehicleID` and beat `r beatID`:

```{r dayGPSrecordsAllVehicle, echo=FALSE}
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteServiceBeatGroup_idWasteServiceBeatGroup = :a'
beatGpsRecords <- dbGetQuery(conDB, q, params = list(a = beatID))

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteVehicles_idWasteVehicles = :a'
vehicleGPSRecords <- dbGetQuery(conDB, q, params = list(a = vehicleID))

dbDisconnect(conDB)

dateData <- read.csv('dateDatasetTraining.csv')
days = c(serviceDay)

beatGpsRecordsFilter_all <- beatGpsRecords %>% inner_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates'))

beatGpsRecordsFilter <- beatGpsRecords %>% inner_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) %>% filter(WasteVehicles_idWasteVehicles != vehicleID)

vehicleGPSRecordsFilter <- vehicleGPSRecords %>% inner_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) %>% filter(dayOfWeek_int %in% days)

beatMap <- returnMap(beatGpsRecordsFilter, zoomStart = 14, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")

beatRecords <- filter(beatRecordsBoundary, idWasteServiceBeatGroup == beatID)

x_buf = 0.004
y_buf = 0.002
zoomArea2_xlim <- c(beatRecords$boundBox_minLong[1] - x_buf, beatRecords$boundBox_maxLong[1] + x_buf)
zoomArea2_ylim <- c(beatRecords$boundBox_minLat[1] - y_buf, beatRecords$boundBox_maxLat[1] + y_buf)

beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'black', size = 1.5) + geom_point(data = beatGpsRecordsFilter_all, aes(x = long, y = lat), alpha = 0.25, size = 0.5, col="darkred") + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
beatPointMap

ggsave(beatPointMap, filename = 'gpsBeatGPS.pdf', width = 15, height = 20.5, units = 'cm')

beatPointPlot <- ggplot() + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'black', size = 1.5) + geom_point(data = beatGpsRecordsFilter_all, aes(x = long, y = lat), alpha = 0.25, size = 0.5, col="darkred") + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))  + blank_all + coord_quickmap() 
beatPointPlot

ggsave(beatPointPlot, filename = 'gpsBeatGPSplot.pdf', width = 15, height = 20.5, units = 'cm')

beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkred', size = 1.5) + geom_point(data = beatGpsRecordsFilter, aes(x = long, y = lat), alpha = 0.5, size = 0.25) + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
beatPointMap

ggsave(beatPointMap, filename = 'gpsBeatGPSother.pdf', width = 15, height = 18.75, units = 'cm')


beatPoint <- ggplot() + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkgrey', size = 1.5) + geom_point(data = vehicleGPSRecordsFilter, aes(x = long, y = lat), alpha = 0.5, size = 0.25, col="darkred") + geom_point(data = beatGpsRecordsFilter, aes(x = long, y = lat), alpha = 0.35, size = 0.25, col = "black")  + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0)) + blank_all + coord_quickmap()
beatPoint

```

### Beat service vehicle records full paths

Retrieve full path of `r vehicleID` on service day `r serviceDay`:

```{r singleVehicleDayFull, echo=FALSE}

x_buf = 0.0005
y_buf = 0.0005

zoomArea3_xlim <- c(18.631260 - x_buf, max(vehicleGPSRecordsFilter$long) + x_buf)
zoomArea3_ylim <- c(-33.931421 - y_buf, max(beatRecords$lat) + y_buf)

dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteVehicles_idWasteVehicles = :a'
vehicleGPSRecords <- dbGetQuery(conDB, q, params = list(a = vehicleID))

days = c(serviceDay)
vehicleGPSRecordsFilter <- vehicleGPSRecords %>% inner_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) %>% filter(dayOfWeek_int %in% days)

dbDisconnect(conDB)

vehicleGPSRecordsFilterRetrieve <- vehicleGPSRecordsFilter %>% filter(long > zoomArea3_xlim[1] & long < zoomArea3_xlim[2] &
                                                                        lat > zoomArea3_ylim[1] & lat < zoomArea3_ylim[2])

vehicleMap <- returnMap(vehicleGPSRecordsFilterRetrieve, zoomStart = 12, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")

# Vehicle landfill
dispose <- read.csv('disposalFacilities.csv')
disposeLim = dispose[c(1, 7),]
depotLim = dispose[c(8),]

vehiclePath <- ggplot() + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "black", size = 0.5) + 
  geom_path(data = vehicleGPSRecordsFilter, aes(x = long, y = lat, group = date), col = "darkred", alpha = 0.15, size = 0.25) +
  geom_point(data = disposeLim, aes(x = long, y = lat), col = "black", size=2)  +
  geom_point(data = depotLim, aes(x = long, y = lat), col = "black", size=2)  + scale_x_continuous(limits = zoomArea3_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea3_ylim, expand = c(0, 0)) + blank_all + coord_quickmap()
vehiclePath # REALLY NICE PLOT! Should look better when converted to a map.

ggsave(vehiclePath, filename = 'gpsVehiclePlot.pdf', width = 15, height = 20.5, units = 'cm')

vehiclePathMap <- vehicleMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "black", size = 0.5) + 
  geom_path(data = vehicleGPSRecordsFilter, aes(x = long, y = lat, group = date), col = "darkred", alpha = 0.15, size = 0.25) +
  geom_point(data = disposeLim, aes(x = long, y = lat), col = "black", size=2)  +
  geom_point(data = depotLim, aes(x = long, y = lat), col = "black", size=2)  + scale_x_continuous(limits = zoomArea3_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea3_ylim, expand = c(0, 0))
vehiclePathMap

ggsave(vehiclePathMap, filename = 'gpsVehicle.pdf', width = 15, height = 20.5, units = 'cm')
```

### Single day distance and speed analysis

Show the distance from the landfill and daily speed on `r analysisDay`:

```{r speedDistance, echo=FALSE}
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteVehicles_idWasteVehicles == %i AND ServiceDates_idServiceDates == %i'
q <- sprintf(q, vehicleID, dayID)
vehicleRecords <- dbGetQuery(conDB, q) 

dbDisconnect(conDB)

vehicleRecords <- vehicleRecords %>% left_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) %>% mutate(date_time = paste(date, time)) %>% arrange(date_time) %>% mutate(time_con = hms(time)) %>% filter(lat < -30 & long > 15)

dispose <- read.csv('disposalFacilities.csv')[7,]

vehicleRecords$distToIF <- round(findIF(dispose, vehicleRecords)[[2]]/1000, 2)
vehicleRecords$time_con <- strptime(vehicleRecords$time, format = '%T')

vehicleRecords$col = "black"
vehicleRecords[vehicleRecords$WasteServiceBeatGroup_idWasteServiceBeatGroup == 679,]$col = "darkred"

distfillDistPlot <- ggplot(vehicleRecords, aes(x = time_con, y = distToIF)) + geom_point(col = vehicleRecords$col) + theme_bw() + xlab('Time of day') + ylab('Distance from landfill (km)') + theme(panel.border=element_blank())
distfillDistPlot

ggsave(distfillDistPlot, filename = 'gpsDistLand.pdf', width = 20, height = 15, units = "cm")

timeDelta_sec <- as.numeric(diff(vehicleRecords$time_con), units = "secs")

vehicleRecordsSub <- vehicleRecords[c(TRUE, timeDelta_sec > 1),]
timeDelta_sec <- as.numeric(diff(vehicleRecordsSub$time_con), units = "secs")

distDiff_m <- calcDeltaD(vehicleRecordsSub$long, vehicleRecordsSub$lat)
speed_kmh <- distDiff_m/timeDelta_sec*3.6

vehicleRecordsSub$speed_kmh <- c(0, speed_kmh)

speedPlot <- ggplot(vehicleRecordsSub, aes(x = time_con, y = speed_kmh)) + geom_point(col = vehicleRecordsSub$col) + theme_bw() + xlab('Time of day') + ylab('Vehicle speed (km)')
speedPlot
```

### Extract IF routes

```{r ExtractIFroute}

vehicleRecords <- vehicleRecords[order(vehicleRecords$time),]

min(vehicleRecords$distToIF)

route1 <- subset(vehicleRecords, time < "10:05:00.0000")
route2 <- subset(vehicleRecords, time >= "10:05:00.0000")

vehicleMap <- returnMap(vehicleRecords, zoomStart = 12, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")
vehicleMap

x_buf = 0.004
y_buf = 0.002
zoomArea2_xlim <- c(min(vehicleRecords$long) - x_buf, max(vehicleRecords$long) + x_buf)
zoomArea2_ylim <- c(min(vehicleRecords$lat) - y_buf, max(beatRecords$boundBox_maxLat) + y_buf)

dispose <- read.csv('disposalFacilities.csv')
disposeLim = dispose[c(1, 7),]
depotLim = dispose[c(8),]

vehiclePathMap <- vehicleMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "blue", size = 1) + 
  geom_path(data = vehicleRecords, aes(x = long, y = lat), col = vehicleRecords$col, alpha = 1, size = 0.75) +
  geom_point(data = disposeLim, aes(x = long, y = lat), col = "black", size=2)  +
  geom_point(data = depotLim, aes(x = long, y = lat), col = "black", size=2)  + 
  scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
vehiclePathMap

ggsave(vehiclePathMap, filename = 'gpsVehicle.pdf', width = 15, height = 20.5, units = 'cm')

vehiclePathMap1 <- vehicleMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "blue", size = 1) + 
  geom_path(data = route1, aes(x = long, y = lat), col = route1$col, alpha = 1, size = 0.75) +
  geom_point(data = disposeLim, aes(x = long, y = lat), col = "black", size=2)  +
  geom_point(data = depotLim, aes(x = long, y = lat), col = "black", size=2)  + 
  scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
vehiclePathMap1

ggsave(vehiclePathMap1, filename = 'gpsVehicle_sub1.pdf', width = 15, height = 20.5, units = 'cm')

vehiclePathMap2 <- vehicleMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "blue", size = 1) + 
  geom_path(data = route2, aes(x = long, y = lat), col = route2$col, alpha = 1, size = 0.75) +
  geom_point(data = disposeLim, aes(x = long, y = lat), col = "black", size=2)  +
  geom_point(data = depotLim, aes(x = long, y = lat), col = "black", size=2)  + 
  scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
vehiclePathMap2

ggsave(vehiclePathMap2, filename = 'gpsVehicle_sub2.pdf', width = 15, height = 20.5, units = 'cm')

route1sub <- subset(route1, col == "darkred")
route2sub <- subset(route2, col == "darkred")

beatMap <- returnMap(beatRecords, zoomStart = 14, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")
beatMap

x_buf = 0.004
y_buf = 0.002
zoomArea2_xlim <- c(beatRecords$boundBox_minLong[1] - x_buf, beatRecords$boundBox_maxLong[1] + x_buf)
zoomArea2_ylim <- c(beatRecords$boundBox_minLat[1] - y_buf, beatRecords$boundBox_maxLat[1] + y_buf)

vehicle1points <- beatMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "blue", size = 1) + 
  geom_point(data = route1sub, aes(x = long, y = lat), col = route1sub$col, alpha = 1, size = 1.5) +
  scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
vehicle1points

ggsave(vehicle1points, filename = 'gpsVehicle_sub1B.pdf', width = 15, height = 20.5, units = 'cm')

vehicle2points <- beatMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "blue", size = 1) + 
  geom_point(data = route2sub, aes(x = long, y = lat), col = route2sub$col, alpha = 1, size = 1.5) +
  scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
vehicle2points

ggsave(vehicle2points, filename = 'gpsVehicle_sub2B.pdf', width = 15, height = 20.5, units = 'cm')

route1sub$col2 <- "darkred"
route2sub$col2 <- "darkred"

route1sub$shape <- 4
route2sub$shape <- 16

serviceRoute <- rbind(route1sub, route2sub)

vehicleServicePoints <- beatMap + 
  geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = "blue", size = 1) + 
  geom_point(data = serviceRoute, aes(x = long, y = lat), shape = serviceRoute$shape, col = serviceRoute$col2, alpha = 1, size = 1.5) +
  scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
vehicleServicePoints

ggsave(vehicleServicePoints, filename = 'gpsVehicle_service.pdf', width = 15, height = 20.5, units = 'cm')
```

### Beat cost calculations

Calculate the service cost for the area over the period (cost calculations are available in costValues sheet under data/costs and are based on values in the MOOC on Waste Management for Developing Countries). The kost/km is `kostPerKm = 16.484`, and the cost per hour is `kostPerHour = 178.816`.

```{r calcServiceCost, echo=FALSE}
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteVehicles_idWasteVehicles == %i'
q <- sprintf(q, vehicleID)

vehicleRecords <- dbGetQuery(conDB, q) %>% left_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) %>% filter(dayOfWeek_int == serviceDay) %>% mutate(date_time = paste(date, time)) %>% arrange(date_time) %>% mutate(time_con = hms(time)) %>% filter(lat < -30 & long > 15)

dbDisconnect(conDB)

recordsPerServiceDay <- vehicleRecords %>% group_by(date) %>% summarise(nRecordsDate = n()) 
ggplot(vehicleRecords, aes(x = date)) + geom_bar() + theme_bw() + coord_flip()

nDays <- nrow(recordsPerServiceDay)
outputFrame <- data.frame(beatID = rep(0, nDays),
                          analysisDay = rep(NA, nDays),
                          serviceTime = rep(0, nDays),
                          totalTime = rep(0, nDays),
                          totalDeadTime = rep(0, nDays),
                          timeUtilisation = rep(NA, nDays),
                          serviceKm = rep(0, nDays),
                          totalKm = rep(0, nDays),
                          totalDeadKm = rep(0, nDays),
                          distanceUtilisation = rep(NA, nDays),
                          travelCost = rep(0, nDays),
                          timeCost = rep(0, nDays),
                          totalCost = rep(0, nDays),
                          serviceTravelCost = rep(0, nDays),
                          serviceTimeCost = rep(0, nDays),
                          serviceTotalCost = rep(0, nDays),
                          serviceCostFraction = rep(0, nDays))

for (i in 1:nDays)
{
  print(paste(i, 'of', nDays))
  analysisDay <- as.character(recordsPerServiceDay$date[i])
  costInfo <- beatCost(vehicleRecords, analysisDay, beatID, dispose)
  if (length(costInfo) > 0)
  {
    outputFrame[i,] <- c(beatID, analysisDay, costInfo)
  }else{
    outputFrame[i,c(1:2)] <- c(beatID, analysisDay)
  }
}
outputFrame$serviceTotalCost <- as.numeric(outputFrame$serviceTotalCost)
outputFrame$totalCost <- as.numeric(outputFrame$totalCost)
outputFrameAll <- outputFrame

outputFrame <- subset(outputFrame, outputFrame$analysisDay != '2014-03-25' & outputFrame$analysisDay != '2014-01-21')

outputFrame$displayDay <- 1:nrow(outputFrame)

summary(as.integer(outputFrame$totalCost))

outputFrame$totalTime = as.numeric(outputFrame$totalTime)
outputFrame$serviceTime = as.numeric(outputFrame$serviceTime)
outputFrame$totalDeadTime = as.numeric(outputFrame$totalDeadTime)

timeFrame1 <- data.frame(x = as.factor(outputFrame$displayDay), y = outputFrame$serviceTime)
timeFrame1$heading = 'A'
timeFrame2 <- data.frame(x = as.factor(outputFrame$displayDay), y = outputFrame$totalDeadTime)
timeFrame2$heading = 'B'
timeFrame = rbind(timeFrame1, timeFrame2)

timeBarPlot <- ggplot(timeFrame, aes(x = x, y = y, fill = heading)) + geom_bar(stat = "identity") + theme_bw() +
  xlab('Twenty-three consecutive collection days of the beat') + ylab('Time (hours) spent to service the beat') + geom_abline(slope = 0, intercept = mean(outputFrame$totalTime), col="darkred") +  scale_fill_manual(values = c("#666666", "grey")) +
  theme(panel.border=element_blank(),axis.text.x=element_blank(), axis.ticks.x=element_blank(), panel.grid.major.x=element_blank(),
                  panel.grid.minor.x=element_blank()) + geom_abline(slope = 0, intercept = mean(outputFrame$serviceTime), col="darkblue")
timeBarPlot
mean(outputFrame$totalTime)
mean(outputFrame$serviceTime)

ggsave(timeBarPlot, filename = 'gpsTimeBar.pdf', width = 20, height = 15, units = "cm")

timeFrameTotal1 <- data.frame(y = sum(outputFrame$serviceTime))
timeFrameTotal1$heading = 'A'
timeFrameTotal2 <- data.frame(y = sum(outputFrame$totalDeadTime))
timeFrameTotal2$heading = 'B'
timeFrameTotal = rbind(timeFrameTotal1, timeFrameTotal2)

pie(x = c(sum(outputFrame$serviceTime), sum(outputFrame$totalDeadTime)))
sum(outputFrame$serviceTime)/(sum(outputFrame$serviceTime) + sum(outputFrame$totalDeadTime))
1 - sum(outputFrame$serviceTime)/(sum(outputFrame$serviceTime) + sum(outputFrame$totalDeadTime))

outputFrame$serviceKm = as.numeric(outputFrame$serviceKm)
outputFrame$totalDeadKm = as.numeric(outputFrame$totalDeadKm)
outputFrame$totalKm = as.numeric(outputFrame$totalKm)

distanceFrame1 <- data.frame(x = as.factor(outputFrame$displayDay), y = outputFrame$serviceKm)
distanceFrame1$heading = 'A'
distanceFrame2 <- data.frame(x = as.factor(outputFrame$displayDay), y = outputFrame$totalDeadKm)
distanceFrame2$heading = 'B'
distanceFrame = rbind(distanceFrame1, distanceFrame2)

distanceBarPlot <- ggplot(distanceFrame, aes(x = x, y = y, fill = heading)) + geom_bar(stat = "identity") + theme_bw() +
  xlab('Twenty-three consecutive collection days of the beat') + ylab('Distance (km) travelled to service the beat') + geom_abline(slope = 0, intercept = mean(outputFrame$totalKm), col="darkred") +  scale_fill_manual(values = c("#666666", "grey")) +
  theme(panel.border=element_blank(),axis.text.x=element_blank(), axis.ticks.x=element_blank(), panel.grid.major.x=element_blank(),
                  panel.grid.minor.x=element_blank()) + geom_abline(slope = 0, intercept = mean(outputFrame$serviceKm), col="darkblue")
distanceBarPlot

mean(outputFrame$totalKm)
mean(outputFrame$serviceKm)

pie(x = c(sum(outputFrame$serviceKm), sum(outputFrame$totalDeadKm)))
sum(outputFrame$serviceKm)/(sum(outputFrame$totalDeadKm) + sum(outputFrame$serviceKm))
1 - sum(outputFrame$serviceKm)/(sum(outputFrame$totalDeadKm) + sum(outputFrame$serviceKm))


ggsave(distanceBarPlot, filename = 'gpsDistanceBar.pdf', width = 20, height = 15, units = "cm")


outputFrame$totalCostDOLLAR = outputFrame$totalCost/14
beatCostDollar <- ggplot(outputFrame, aes(x = as.factor(displayDay), y = totalCostDOLLAR)) + geom_bar(stat = "identity", fill = "grey", col="darkgrey") + theme_bw() +
  xlab('Weekly service day of collection area over a period of 6 months') + ylab('Cost to service area (in US$)') + geom_abline(slope = 0, intercept = mean(outputFrame$totalCostDOLLAR), col="darkred") + theme(panel.border=element_blank(),                  axis.text.x=element_blank(),
                  axis.ticks.x=element_blank(),
                                    panel.grid.major.x=element_blank(),
                  panel.grid.minor.x=element_blank())

beatCostDollar

ggsave(beatCostDollar, filename = 'gpsBeatCostDollar.pdf', width = 20, height = 15, units = "cm")

outputFrame$totalCostDOLLAR = outputFrame$totalCost/14
beatCostRand <- ggplot(outputFrame, aes(x = as.factor(displayDay), y = totalCost)) + geom_bar(stat = "identity", fill = "grey", col="darkgrey") + theme_bw() +
  xlab('Weekly service day of collection area over a period of 6 months') + ylab('Cost to service area (in South African Rand)') + geom_abline(slope = 0, intercept = mean(outputFrame$totalCost), col="darkred") + theme(panel.border=element_blank(),                  axis.text.x=element_blank(),
                  axis.ticks.x=element_blank(),
                                    panel.grid.major.x=element_blank(),
                  panel.grid.minor.x=element_blank())

beatCostRand

ggsave(beatCostRand, filename = 'gpsBeatCostDollar.pdf', width = 20, height = 15, units = "cm")


beatCostRandPoint <- ggplot(outputFrame, aes(x = as.factor(displayDay), y = totalCost)) + geom_point(fill = "grey", col="darkgrey") + theme_bw() +
  xlab('Weekly service day of collection area over a period of 6 months') + ylab('Cost to service area (in South African Rand)') + geom_abline(slope = 0, intercept = mean(outputFrame$totalCost), col="darkred") + theme(panel.border=element_blank(),                  axis.text.x=element_blank(),
                  axis.ticks.x=element_blank(),
                                    panel.grid.major.x=element_blank(),
                  panel.grid.minor.x=element_blank())

beatCostRandPoint


beatCostRand_hist <- ggplot(filter(outputFrame, totalCost > 1000), aes(x = totalCost)) + geom_histogram(fill = "grey", col="darkgrey", bins=5) + theme_bw() +
  xlab('Weekly service cost (in South African Rand) of collection area') + ylab('Frequency') + geom_vline(xintercept = mean(outputFrame$totalCost), col="darkred") + theme(panel.border=element_blank())       

beatCostRand_hist

```

## Synthetic population

### Basic stats

Basic stats for the service area, with the following income classification:

LOW (1, "Low income (R0 - R3200 monthly)"),
		LOWMIDDLE (2, "Low middle income (R3201 - R25600 monthly)"),
		HIGHMIDDLE (3, "High middle income (R25601 - R51200 monthly)"),
		HIGH (4, "High income (R51201 or more monthly)"),
		UNKNOWN (5, "Unknown");

```{r SyntheticPopulationStats, echo=TRUE}
lowestIncome <- c(0, 4800, 9600, 19200, 38400)
lowerMiddleIncome <- c(76800, 153600, 307200) 
upperMiddleIncome <- c(614400)
highIncome <- c(1228800, 2457600, 4915200)

syn <- read.csv('../data/syntheticPopulation/population_RandomHouseLocation.csv')
syn$incomeGroup = '0 low'
syn[syn$income %in% lowerMiddleIncome,]$incomeGroup = '1 lowMiddle'
syn[syn$income %in% upperMiddleIncome,]$incomeGroup = '2 highMiddle'
syn[syn$income %in% highIncome,]$incomeGroup = '3 high'

nPeople <- nrow(syn)

syn$isEmployedInt <- 1
syn[syn$isEmployed == 'false',]$isEmployedInt <- 0

householdSyn <- syn %>% group_by(hhId) %>% summarise(nMembers = n(), income = max(income), nEmployed = sum(isEmployedInt), oneEmployed = max(isEmployedInt), incomeGroup = max(incomeGroup))

#Number of households and number of people
nHouseholds <- nrow(householdSyn)
nHouseholds
nPeople

#To display is age distribution
hist(syn$age, xlab = "Age")
barplot(table(syn$gender), xlab = "Gender distribution", ylab = "Frequency")

# Members per household
barplot(table(householdSyn$nMembers), xlab = "Number of members per household", ylab = "Frequency")

# Barharts or pie-charts for employment
barplot(table(syn$isEmployed), ylab = "Frequency", xlab = "Employed (per person)")
barplot(table(householdSyn$nEmployed), ylab = "Frequency", xlab = 'Number in house employed')
barplot(table(householdSyn$oneEmployed), xlab = "At least one in house employed", ylab = "Frequency")

# Income distribution with colors for low, medium and high income households
barplot(table(householdSyn$income), ylab = "Frequency", xlab = "Household income")

incomeLevels <- unique(householdSyn$income)
incomeLevels <- incomeLevels[order(incomeLevels)]

# Estimation of waste generation per household (number of people times income of household)
lowerGen <- c(0.09, 4.3, 0.60) # kg per person per day
LowerMiddleGen <- c(0.16, 5.3, 0.79) # kg per person per day
UpperMiddleGen <- c(0.11, 5.5, 1.2) # kg per person per day (lower boubd lower than lower mid??)
HighGen <- c(0.70, 14, 2.1) # kg per person per day

lowerGen_Cpt <- c(0.09*1.7, 4.3, 0.60) # kg per person per day
LowerMiddleGen_Cpt <- c(0.16*1.7, 5.3, 0.79) # kg per person per day
UpperMiddleGen_Cpt <- c(0.16*1.7, 5.5, 1.2) # kg per person per day
HighGen_Cpt <- c(0.70*1.7, 14, 2.1) # kg per person per day

householdSyn$generateRateAve = lowerGen_Cpt[1]
householdSyn[householdSyn$incomeGroup == '1 lowMiddle',]$generateRateAve = LowerMiddleGen_Cpt[1]
householdSyn[householdSyn$incomeGroup == '2 highMiddle',]$generateRateAve = UpperMiddleGen_Cpt[1]
householdSyn[householdSyn$incomeGroup == '3 high',]$generateRateAve = HighGen_Cpt[1]

householdSyn$totalPerWeek <- householdSyn$generateRateAve*householdSyn$nMembers*7

hist(householdSyn$totalPerWeek, xlab = "Total collectable waste (kg) generated per week")

total <- sum(householdSyn$totalPerWeek)
total/7000 # number of offloads required to service area.

# Mean cost per household (number of household / total cost)

costPerWeek <- mean(outputFrame$totalCost)
weeksPerYear <- 365/7

annualWasteCollectionCost <- weeksPerYear*costPerWeek
annualWasteCollectionCost

annualWaste <- total*weeksPerYear
annualWaste

kostPerHousehold <- annualWasteCollectionCost/nHouseholds
kostPerHousehold

# Mean cost per person (number of people / total cost)

kostPerPerson <- annualWasteCollectionCost/nPeople
kostPerPerson

# Mean cost per waste (total waste / total cost)

kostPerKg <- annualWasteCollectionCost/annualWaste
kostPerKg

# Assignable cost per houshold (housholdWaste(total waste) * total cost) Doesn't make sense since population is an 
# approximation.

incomeStats <- householdSyn %>% group_by(incomeGroup) %>% summarize(totalPerWeek = sum(totalPerWeek),
                                                                    income = max(income),
                                                                    nPeople = sum(nMembers),
                                                                    nHouses = n(),
                                                                    totalEmp = sum(nEmployed),
                                                                    totalHouseEmp = sum(oneEmployed))

barplot(incomeStats$totalPerWeek, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main="Waste (kg) per year")
barplot(incomeStats$nPeople, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main = "Number of people")

table(householdSyn$incomeGroup)
prop.table(table(householdSyn$incomeGroup))

barplot(incomeStats$nHouses, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main = "Number of properties")
barplot(incomeStats$totalEmp, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main = "Number of employed people")
barplot(incomeStats$totalHouseEmp, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main = "Number of employed households")

incomeStats$WasteFrac = incomeStats$totalPerWeek/sum(incomeStats$totalPerWeek) 
barplot(incomeStats$WasteFrac, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main ="Fraction of total waste produced")

incomeStats$ProportionalCost = incomeStats$WasteFrac*annualWasteCollectionCost
incomeStats$PropCostPH = incomeStats$ProportionalCost/incomeStats$nHouses
barplot(incomeStats$PropCostPH, ylab = "Frequency", names.arg = incomeStats$incomeGroup, main = "Cost (Rand) per year per household")

incomeStats
```

### Geographical locations

Allocate the synthetic population close to the street network:

```{r synthAllocation}

syn <- read.csv('../data/syntheticPopulation/population_RandomHouseLocation.csv')

dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM WasteServiceBoundaryPoint'
boundaryRecords <- dbGetQuery(conDB, q)

q <- 'SELECT * FROM WasteServiceBeatGroup'
beatRecords <- dbGetQuery(conDB, q)

q <- 'SELECT * FROM ConvertedGpsRecord WHERE WasteServiceBeatGroup_idWasteServiceBeatGroup = :a'
beatGpsRecords <- dbGetQuery(conDB, q, params = list(a = beatID))

dbDisconnect(conDB)

beatRecordsBoundary <- right_join(beatRecords, boundaryRecords, by = c('idWasteServiceBeatGroup' = 'WasteServiceBeat_idWasteServiceBeatGroup'))

dateData <- read.csv('dateDatasetTraining.csv')
days = c(2)
beatGpsRecordsFilter <- beatGpsRecords %>% inner_join(dateData, by = c('ServiceDates_idServiceDates' = 'idServiceDates')) %>% filter( WasteVehicles_idWasteVehicles == vehicleID & ServiceDates_idServiceDates == 44) 

beatMap <- returnMap(beatGpsRecordsFilter, zoomStart = 14, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")

beatRecords <- filter(beatRecordsBoundary, idWasteServiceBeatGroup == beatID)

x_buf = 0.004
y_buf = 0.004
zoomArea2_xlim <- c(beatRecords$boundBox_minLong[1] - x_buf, beatRecords$boundBox_maxLong[1] + x_buf)
zoomArea2_ylim <- c(beatRecords$boundBox_minLat[1] - y_buf, beatRecords$boundBox_maxLat[1] + y_buf)


beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkred', size = 1.5) + geom_point(data = beatGpsRecordsFilter, aes(x = long, y = lat), alpha = 0.5, size = 0.25) + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
beatPointMap

nSyn <- length(unique(syn$hhId))
newSyn <- syn
nVeh <- nrow(beatGpsRecordsFilter)
set.seed(100)

syn$long = syn$lon
newSyn$long = newSyn$lon

for (hid in unique(syn$hhId))
{
  s <- sample(c(1:nVeh), size = 1)  
  newCoordX <- beatGpsRecordsFilter[s,]$long
  newCoordY <- beatGpsRecordsFilter[s,]$lat
  print(paste(newCoordX, newCoordY))
  newSyn[(syn$hhId == hid),]$long = newCoordX + runif(1, -0.0005, 0.0005)
  newSyn[(syn$hhId == hid),]$lat = newCoordY + runif(1, -0.0005, 0.0005)
}

lowestIncome <- c(0, 4800, 9600, 19200, 38400)
lowerMiddleIncome <- c(76800, 153600, 307200) 
upperMiddleIncome <- c(614400)
highIncome <- c(1228800, 2457600, 4915200)

newSyn <- read.csv('../data/syntheticPopulation/population_RandomHouseLocation.csv')
newSyn$incomeGroup = 'low'
newSyn[newSyn$income %in% lowerMiddleIncome,]$incomeGroup = 'lowMiddle'
newSyn[newSyn$income %in% upperMiddleIncome,]$incomeGroup = 'highMiddle'
newSyn[newSyn$income %in% highIncome,]$incomeGroup = 'high'

syn_house <- newSyn %>% group_by(hhId) %>% summarise(long = max(long), lat = max(lat), income = max(incomeGroup))

beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkblue', size = 1.5) + geom_point(data = syn_house, aes(x = long, y = lat), alpha = 0.75, size = 1, col = "black") + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
beatPointMap
ggsave(beatPointMap, filename = 'gpsSynLocation.pdf', width = 15, height = 23.5, units = 'cm')

```

### Full synthetic population

```{r}
fullSynths <- read.csv('../data/syntheticPopulation/householdBeats.csv')
myBeat <- 'allBeats_WGS84.535'
beatSynth <- filter(fullSynths, beatId == myBeat)
beatSynth$lon_fact = beatSynth$lon
beatSynth$lat_fact <- as.factor(beatSynth$lat)
beatSynth$lon_lat_com = paste(beatSynth$lon_fact, beatSynth$lat_fact)
beatSynth$lon = as.numeric(as.character(beatSynth$lon))

min(beatSynth$lon)
max(beatSynth$lon)
min(beatSynth$lat)
max(beatSynth$lat)

p <- ggplot(beatSynth, aes(x = lon, y = lat)) + geom_point(alpha = 0.25) + coord_quickmap() + theme_bw()
p

p2 <- ggplot(beatSynth, aes(x = lon, y = lat)) + coord_quickmap() + theme_bw()
p2 + geom_jitter(width = 0.0005, height =  0.0005)

beatSynthCounts <- beatSynth %>% group_by(lon_fact, lat_fact) %>% summarise(nHouses = n())
beatSynthCounts$houseType <- 'single'
beatSynthCounts[beatSynthCounts$nHouses > 1,]$houseType <- 'multi'
beatSynthCounts[beatSynthCounts$nHouses > 10,]$houseType <- 'multi_dense'
beatSynthCounts$lon_lat_com = paste(beatSynthCounts$lon_fact, beatSynthCounts$lat_fact)
beatSynthCounts$lon_fact = NULL
beatSynthCounts$lat_fact = NULL

beatSynth = merge(beatSynth, beatSynthCounts)

p_full <- ggplot(subset(beatSynth, houseType != 'multi_dense'), aes(x = lon, y = lat)) + geom_point(alpha = 0.25) + coord_quickmap() + theme_bw() + geom_jitter(data = subset(beatSynth, houseType == 'multi_dense'), width = 0.0005, height =  0.0005, alpha = 0.25)
p_full

syn <- beatSynth
syn$long = syn$lon
dbPath <- '../data/dataBaseStructure/dbs/CapeTown_Waste_mod.db'
conDB <- dbConnect(RSQLite::SQLite(), dbname = dbPath)

q <- 'SELECT * FROM WasteServiceBoundaryPoint'
boundaryRecords <- dbGetQuery(conDB, q)

q <- 'SELECT * FROM WasteServiceBeatGroup'
beatRecords <- dbGetQuery(conDB, q)

beatRecordsBoundary <- right_join(beatRecords, boundaryRecords, by = c('idWasteServiceBeatGroup' = 'WasteServiceBeat_idWasteServiceBeatGroup'))

beatRecords <- filter(beatRecordsBoundary, idWasteServiceBeatGroup == beatID)

beatMap <- returnMap(beatRecords, zoomStart = 14, googleStyle = "feature:all|element:labels|visibility:off&style=feature:road.local|visibility:on")

beatRecords <- filter(beatRecordsBoundary, idWasteServiceBeatGroup == beatID)

x_buf = 0.004
y_buf = 0.004
zoomArea2_xlim <- c(beatRecords$boundBox_minLong[1] - x_buf, beatRecords$boundBox_maxLong[1] + x_buf)
zoomArea2_ylim <- c(beatRecords$boundBox_minLat[1] - y_buf, beatRecords$boundBox_maxLat[1] + y_buf)

beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkred', size = 1.5) + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0))
beatPointMap

beatPointMap <- beatMap + geom_path(data = beatRecords, aes(x = long, y = lat, group = idWasteServiceBeatGroup), col = 'darkblue', size = 1.5) + geom_point(data = subset(beatSynth, houseType != 'multi_dense'), aes(x = lon, y = lat), alpha = 0.6, size = 1, col = "black") + scale_x_continuous(limits = zoomArea2_xlim, expand = c(0, 0)) + scale_y_continuous(limits = zoomArea2_ylim, expand = c(0, 0)) + geom_jitter(data = subset(beatSynth, houseType == 'multi_dense'), width = 0.00065, height =  0.00065, alpha = 0.6, size = 1, col = "black")
beatPointMap
ggsave(beatPointMap, filename = 'gpsSynLocation_fixed.pdf', width = 15, height = 23.5, units = 'cm')
```